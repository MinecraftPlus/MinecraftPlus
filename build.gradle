plugins {
    id 'java'
    id 'de.undercouch.download'
    id 'uk.jamierocks.propatcher' version '2.0.1' apply false
    id 'org.barfuin.gradle.taskinfo' version '1.0.5'
}

repositories {
    mavenCentral()
    mavenLocal()
}

dependencies {
}

// Project special customized gradle tasks
import org.minecraftplus.gradle.tasks.Utils
import org.minecraftplus.gradle.tasks.*
import org.minecraftplus.gradle.tasks.assets.*
import org.minecraftplus.gradle.tasks.jars.*
import org.minecraftplus.gradle.tasks.mapping.*
import org.minecraftplus.gradle.tasks.maven.*
import org.minecraftplus.gradle.tasks.meta.*
import org.minecraftplus.gradle.tasks.repo.*
import org.minecraftplus.gradle.tasks.RunApplication
// Inherit some tasks from MinecraftForge
import net.minecraftforge.mcpconfig.tasks.DownloadTool
import net.minecraftforge.mcpconfig.tasks.DownloadAssets
import net.minecraftforge.mcpconfig.tasks.CreateFernflowerLibraries
import net.minecraftforge.mcpconfig.tasks.ExtractNatives
import net.minecraftforge.mcpconfig.tasks.FernflowerTask
// ProPatcher to generate diffs
import uk.jamierocks.propatcher.task.*

org.minecraftplus.gradle.tasks.Utils.init()

project.ext {
    PATH_SOURCE = file('src').absolutePath + '/'
    PATH_SOURCE_PATCHES = PATH_SOURCE + 'patches/'
    
    PATH_BUILD = file('build').absolutePath + '/'
    PATH_BUILD_LIBRARIES = PATH_BUILD + 'libraries/'
    PATH_BUILD_META = PATH_BUILD + 'meta/'

    PATH_PROJECTS = file('projects').absolutePath + '/'

    PATH_CONFIG = file('config').absolutePath + '/'
    PATH_CONFIG_CHECKSTYLE = PATH_CONFIG + 'checkstyle/'
    PATH_CONFIG_TEMPLATES = PATH_CONFIG + 'templates/'

    CONFIG = file(PATH_CONFIG + 'config.yaml').yaml

    PROJECT_VERSION = CONFIG.get('project_version', '0.0.0-SNAPSHOT')
    MINECRAFT_VERSION = CONFIG.get('minecraft_version', '1.15.2')
    JAVA_TARGET = CONFIG.get('java_target', 8)

    FERNFLOWER = Utils.toolConfig(CONFIG, 'fernflower', [
            version: 'net.minecraftforge:forgeflower:1.5.498.22',
            args: ["-din=1", "-rbr=1", "-dgs=1", "-asc=1", "-rsy=1", "-iec=1", "-isl=0", "-log=TRACE", "-cfg", "{libraries}", "{input}", "{output}"],
            jvmargs: ["-Xmx4G"]
    ])
    MERGETOOL = Utils.toolConfig(CONFIG, 'merge', [
            version: 'net.minecraftforge:mergetool:1.1.3:fatjar',
            args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
    ])
    RENAMETOOL = Utils.toolConfig(CONFIG, 'rename', [
            version: 'org.minecraftplus:vignette:0.3.0.0',
            args: ["--jar-in", "{input}", "--jar-out", "{output}", "--mapping-format", "tsrg2", "--mappings", "{mappings}", "--cfg", "{libraries}", "--deduce-param-names", "--dictionary", "{dictionary}", "--create-inits", "--fernflower-meta"]
    ])

    PRODUCTION_MODE = project.hasProperty('ENV_MODE') && project.property('ENV_MODE') == 'PRODUCTION'
}

group = "org.minecraftplus"
version = PROJECT_VERSION


java.toolchain {
    languageVersion = JavaLanguageVersion.of(JAVA_TARGET)
}


if (PRODUCTION_MODE) {
    logger.lifecycle('Project is in PRODUCTION environment mode!')
}

task downloadMergeTool(group: 'mcplus download', type: DownloadTool) {
    description = 'Downloads merge tool'

    config MERGETOOL, PATH_BUILD_LIBRARIES
}
task downloadRenameTool(group: 'mcplus download', type: DownloadTool) {
    description = 'Downloads rename tool'

    config RENAMETOOL, PATH_BUILD_LIBRARIES
}
task downloadFernflower(group: 'mcplus download', type: DownloadTool) {
    description = 'Downloads decompiler'

    config FERNFLOWER, PATH_BUILD_LIBRARIES
}

task downloadManifest(type: Download) {
    group = 'mcplus download'
    description = 'Downloads version manifest from mojang.com.'

    src 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    dest file(PATH_BUILD + 'version/manifest.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadVersionJson(type: Download) {
    group = 'mcplus download'
    description = 'Downloads minecraft version JSON configuration.'
    dependsOn tasks.downloadManifest

    inputs.file tasks.downloadManifest.dest
    src { tasks.downloadManifest.dest.json.versions.find{ it.id == MINECRAFT_VERSION }.url }
    dest file(PATH_BUILD + 'version/version.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

/**
 * Generate JSON version manifest to pass it to game launcher
 */
task generateVersionJsonMeta(type: GenerateVersionManifest) {
    group = 'mcplus meta'
    description = "Generates version's launcher meta"

    parent tasks.downloadVersionJson.dest
    id "${project.name}-${project.version}"
    type project.version.endsWith("SNAPSHOT") ? "snapshot" : "release"

    manifest file(PATH_BUILD_META + id + '.json')
    manifestFull file(PATH_BUILD_META + id + '_full.json')
}

/**
 * Download client and server JARs
 */
task downloadVersionJars(group: 'mcplus download') {
    description = 'Downloads minecraft version jars (client and server).'
}

['client', 'server'].each { id ->
    def taskName = 'downloadVersion' + id.capitalize() + "Jar"
    def versionTask = task "${taskName}" (type: Download) {
        group = 'mcplus download ' + id
        dependsOn tasks.downloadVersionJson

        inputs.file tasks.downloadVersionJson.dest
        src { tasks.downloadVersionJson.dest.json.downloads.get(id).url }
        dest file(PATH_BUILD + 'version/' + id + '.jar')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    tasks.downloadVersionJars.dependsOn(versionTask)
}

/**
 * Download version libraries with extra added by project configuration
 */
task downloadVersionLibraries(type: DownloadLibraries) {
    group = 'mcplus download'
    description = 'Downloads libraries needed by game version.'
    dependsOn tasks.downloadVersionJson

    json = tasks.downloadVersionJson.dest // TODO Need way to override library version with config? Can client libraries be "hardcoded" in config?
    config = CONFIG
    destination = file(PATH_BUILD_LIBRARIES)
}

/**
 * Download client assets
 */
task downloadVersionAssets(type: DownloadAssets) {
    group = 'mcplus download'
    description = 'Downloads assets used by game version.'
    dependsOn tasks.downloadVersionJson

    json = tasks.downloadVersionJson.dest
    dest = file(PATH_BUILD + 'assets/')
}

/**
 * Package remote assets
 */
task packageVersionAssets(type: PackageAssets) {
    group = 'mcplus process'
    description = 'Packages remote assets used by game version into JAR.'
    dependsOn tasks.downloadVersionJson
    dependsOn tasks.downloadVersionAssets

    json = tasks.downloadVersionJson.dest
    input = tasks.downloadVersionAssets.dest
    dest = file(PATH_BUILD + 'assets/package.jar')
}

/**
 * Extract natives for client
 */
task extractNatives(type: ExtractNatives) {
    group = 'mcplus project'
    dependsOn tasks.downloadVersionJson
    dependsOn tasks.downloadVersionLibraries

    meta tasks.downloadVersionJson.dest
    cache file(PATH_BUILD_LIBRARIES)
    dest file(PATH_BUILD + 'natives/')
}

/**
 * Download official mappings for client and server
 */
task downloadMappings(group: 'mcplus download') {
    description = 'Downloads official mappings.'
}

['client', 'server'].each { side ->
    def taskName = 'download' + side.capitalize() + "Mappings"
    def mappingsTask = task "${taskName}" (type: Download) {
        group = 'mcplus process ' + side
        dependsOn tasks.downloadVersionJson

        inputs.file tasks.downloadVersionJson.dest
        src { tasks.downloadVersionJson.dest.json.downloads.get(side + '_mappings').url }
        dest file(PATH_BUILD + 'mappings/' + side + '_mappings.txt')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    tasks.downloadMappings.dependsOn(mappingsTask)
}

/**
 * Convert official mappings to TSRG2 format
 */
task convertMappings(group: 'mcplus process') {
    description = 'Converts official mappings to TSRG format.'
}

['client', 'server'].each { side ->
    def taskName = 'convert' + side.capitalize() + "Mappings"
    def convertTask = task "${taskName}" (type: ConvertMappings) {
        group = 'mcplus process ' + side
        dependsOn tasks.getByPath("download${side.capitalize()}Mappings")

        input =  tasks.getByPath("download${side.capitalize()}Mappings").dest
        dest = file(PATH_BUILD + 'mappings/' + side + '_mappings.tsrg')
    }
    tasks.convertMappings.dependsOn(convertTask)
}


/**
 * Filter version jars to contain only classes
 */
task filterVersionJars(group: 'mcplus process') {
    description = 'Filters version jars.'
}

['client', 'server'].each { side ->
    def taskName = 'filterVersion' + side.capitalize() + "Jar"
    def filterTask = task "${taskName}" (type: SplitJar) {
        group = 'mcplus process ' + side
        dependsOn tasks.getByPath("convert${side.capitalize()}Mappings")
        dependsOn tasks.getByPath("downloadVersion${side.capitalize()}Jar")

        input = tasks.getByPath("downloadVersion${side.capitalize()}Jar").dest
        mappings = tasks.getByPath("convert${side.capitalize()}Mappings").dest
        acceptable = [ "assets/", "data/", "net/minecraft/", "com/mojang/blaze3d", "com/mojang/realms",
                       "log4j2.xml", "Log4j-config.xsd", "Log4j-events.dtd", "Log4j-events.xsd", "Log4j-levels.xsd",
                       "pack.mcmeta", "pack.png", "version.json"]
        sources = file(PATH_BUILD + 'version/' + side + '.sources.jar')
        resources = file(PATH_BUILD + 'version/' + side + '.resources.jar')
        libraries = file(PATH_BUILD + 'version/' + side + '.libraries.jar')
    }
    tasks.filterVersionJars.dependsOn(filterTask)
}


/**
 * Merge client and server JAR to one annotated with @OnlyIn(Dist.<SIDE>)
 */
task mergeVersionJoinedJar(type: MergeJar) {
    group = 'mcplus process'
    description = 'Merges source JARs into one annotated with Dist marker.'
    dependsOn tasks.downloadMergeTool
    dependsOn tasks.filterVersionClientJar
    dependsOn tasks.filterVersionServerJar

    config MERGETOOL, tasks.downloadMergeTool
    client tasks.filterVersionClientJar.sources
    server tasks.filterVersionServerJar.sources
    dest file(PATH_BUILD + 'version/joined.jar')
    annotations 'API'
}


/**
 * Merge client and server internal resources to joined
 */
task mergeJoinedResources(type: CombineArchives) {
    def side = 'joined'
    group = 'mcplus process ' + side
    description = 'Merges JARs into one.'
    dependsOn tasks.filterVersionClientJar
    dependsOn tasks.filterVersionServerJar

    first tasks.filterVersionClientJar.resources
    second tasks.filterVersionServerJar.resources
    dest file(PATH_BUILD + 'version/joined.resources.jar')
}
tasks.filterVersionJars.dependsOn(tasks.mergeJoinedResources)


/**
 * Process sides configuration
 */
def configs = [
    joined: [Name: 'Joined', jsonlibs: true,  extra: 'Client', assets: true,
             projectTemplate: 'distro_build.gradle',
             mappingsTask: tasks.convertClientMappings,
             splitTask: tasks.mergeVersionJoinedJar,
             resources: 'internal',
             natives: tasks.extractNatives.dest
    ],
    client: [Name: 'Client', jsonlibs: true,  extra: 'Client', assets: true,
             projectTemplate: 'distro_build.gradle',
             mappingsTask: tasks.convertClientMappings,
             splitTask: tasks.filterVersionClientJar,
             natives: tasks.extractNatives.dest
    ],
    server: [Name: 'Server', jsonlibs: false, extra: 'Server', assets: false,
             projectTemplate: 'distro_build.gradle',
             mappingsTask: tasks.convertServerMappings,
             splitTask: tasks.filterVersionServerJar,
             natives: null
    ],
    resources: [
            Name: 'Resources',
            projectTemplate: 'resources_build.gradle',
            decompileTask: tasks.packageVersionAssets, // TODO Make this not needed, as it is in remote sourceset
            sourceSets: [
                    [ suffix: 'internal', task: tasks.mergeJoinedResources, outputDir: 'src/main/internal' ],
                    [ suffix: 'remote', task: tasks.packageVersionAssets, outputDir: 'src/main/remote' ]
            ]
    ]
]

def sides = configs.findAll {
    ['joined', 'client', 'server'].contains(it.key)
}

/**
 * Prepare list of libraries for Vignette and Fernflower
 */
task generateProcessLibraries(group: 'mcplus process') {
    description = 'Renames jars using mappings'
}

sides.each { s, child ->
    def taskName = 'generateProcess' + child.Name + 'Libraries'
    child.librariesTask = task "${taskName}" (type: CreateFernflowerLibraries) {
        group = 'mcplus process ' + s
        dependsOn tasks.downloadVersionLibraries
        dependsOn tasks.downloadVersionJson

        meta = tasks.downloadVersionJson.dest
        config = CONFIG
        side = s
        root = file(PATH_BUILD_LIBRARIES)
        dest file(PATH_BUILD + 'mapped/' + s + '.fernflower.libs.txt')
    }
    tasks.generateProcessLibraries.dependsOn(child.librariesTask)
}

/**
 * Vignette renaming
 */
task renameVersionJars(group: 'mcplus process') {
    description = 'Renames jars using mappings'
}

sides.each { side, child ->
    def taskName = 'renameVersion' + child.Name + 'Jar'
    child.renameTask = task "${taskName}" (type: RemapJar) {
        group = 'mcplus process ' + side
        dependsOn tasks.downloadRenameTool
        dependsOn child.splitTask
        dependsOn child.mappingsTask
        dependsOn child.librariesTask

        config RENAMETOOL, tasks.downloadRenameTool
        input = 'joined'.equals(side) ? child.splitTask.dest : child.splitTask.sources // Use dest if input is from MergeJars
        mappings = child.mappingsTask.dest
        libraries = child.librariesTask.dest
        dictionary = file(PATH_CONFIG + 'dictionary.dict')
        dest = file(PATH_BUILD + 'mapped/' + side + '.mapped.jar')
        log = file(PATH_BUILD + 'mapped/' + side + '.mapped.log')
    }
    tasks.renameVersionJars.dependsOn(child.renameTask)
}

/**
 * Fernflower decompilation
 */
task decompileVersionJars (group: 'mcplus process') {
    description = 'Decompiles jars'
}

sides.each { side, child ->
    def taskName = 'decompileVersion' + child.Name + 'Jar'
    child.decompileTask = task "${taskName}" (type: FernflowerTask) {
        group = 'mcplus process ' + side
        dependsOn tasks.downloadFernflower
        dependsOn child.librariesTask
        dependsOn child.renameTask

        config FERNFLOWER, tasks.downloadFernflower
        javaLauncher = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(JAVA_TARGET)
        }
        libraries = child.librariesTask.dest
        input = child.renameTask.dest

        log = file(PATH_BUILD + '/decompile/' + side + '.decompile.log')
        dest = file(PATH_BUILD + '/decompile/' + side + '.decompile.jar')
    }
    tasks.decompileVersionJars.dependsOn(child.decompileTask)
}



/**
 * Create projects directory
 */
task projectsRootCreate {
    group = 'mcplus project'
    description = 'Creates projects root directory'

    doLast {
        def directory = file(PATH_PROJECTS)
        logger.info("Creating projects root directory {}", directory)
        mkdir directory
    }
}

/**
 * Delete all projects
 */
task projectDeleteAll (group: 'mcplus project') {
    description = 'Deletes all projects from filesystem'
}

/**
 * Delete all projects
 */
task projectCreateAll (group: 'mcplus project') {
    description = 'Creates all distrubution projects'
}

/**
 * Reset source
 */
task projectResetAll (group: 'mcplus project') {
    description = 'Resets sources in all projects'
}

configs.each { side, child ->
    def project_dir = project.file(PATH_PROJECTS + side)
    def patches_dir = project.file(PATH_SOURCE_PATCHES + side)


    child.projectDeleteTask = task "project${child.Name}Delete"(type: Delete) {
        group = 'mcplus project ' + side

        delete project_dir
    }
    tasks.projectDeleteAll.dependsOn(child.projectDeleteTask)

    child.projectCreateTask = task "project${child.Name}Create"(type: CreateProjectWithTemplate) {
        group = 'mcplus project ' + side
        dependsOn tasks.projectsRootCreate
        dependsOn(child.jsonlibs ? [tasks.downloadVersionJson] : [])
        mustRunAfter child.projectDeleteTask

        dest project_dir
        distro side
        template project.file(PATH_CONFIG_TEMPLATES + child.projectTemplate)
        gitignore project.file(PATH_CONFIG_TEMPLATES + 'distro_gitignore')

        if (child.jsonlibs)
            meta tasks.downloadVersionJson.dest
        CONFIG.distributions.get(side).libraries?.each { library "'${it}'" }

        replace '{java_target}', JAVA_TARGET as String
        replace '{resources}', child.resources?: side
        replaceFile '{natives}', child.natives?: null
        replace '{shade}', (!child.jsonlibs || side.equals('joined')) as String

        doFirst {
            if (child.sourceSets) {
                child.sourceSets.each {
                    def directory = new File(project_dir,  it.outputDir as String)
                    logger.info("Creating sourceset directory {}", directory)
                    mkdir directory
                }
            } else {
                def directory = new File(project_dir, 'src/main/java')
                logger.info("Creating standard directory {}", directory)
                mkdir directory
            }
        }
    }
    tasks.projectCreateAll.dependsOn(child.projectCreateTask)

    // Reset tasks
    if (child.sourceSets == null) {
        child.projectResetTask = task "project${child.Name}Reset" (type: ResetSourcesTask) {
            group = 'mcplus project ' + side
            dependsOn child.decompileTask
            dependsOn child.projectCreateTask
            mustRunAfter child.projectCreateTask

            rootZip child.decompileTask.dest
            target new File(project_dir, 'src/main/java')
        }
    } else {
        child.projectResetTask = task "project${child.Name}Reset" {
            group = 'mcplus project ' + side
            description = 'Resets all sourcesets in project'
        }

        child.sourceSets.each {
            def taskSuffix = it.suffix as String
            def sourceTask = it.task as Task
            def outputDirectory = new File(project_dir, it.outputDir as String)

            def taskName = 'project' + child.Name + "Reset" + taskSuffix.capitalize()
            def resetTask = task "${taskName}" (type: ResetSourcesTask) {
                group = 'mcplus project ' + side
                dependsOn sourceTask
                dependsOn child.projectCreateTask
                mustRunAfter child.projectCreateTask

                rootZip sourceTask.dest
                target outputDirectory
            }
            child.projectResetTask.dependsOn(resetTask)
        }
    }
    tasks.projectResetAll.dependsOn(child.projectResetTask)
}


/**
 * Apply patches for all
 */
task projectApplyPatchesAll (group: 'mcplus project') {
    description = 'Applies patches to all projects'
}

/**
 * Make patches for all
 */
task projectMakePatchesAll (group: 'mcplus project') {
    description = 'Makes patches for all projects'
}

configs.each { side, child ->
    def project_dir = project.file(PATH_PROJECTS + side)
    def patches_dir = project.file(PATH_SOURCE_PATCHES + side)

    child.makePatchesDirTask = task "project${child.Name}MakePatchesDir"() {
        group = 'mcplus project ' + side
        doLast {
            mkdir patches_dir
            child.sourceSets.each {
                def directory = new File(patches_dir,  it.suffix as String)
                logger.info("Creating {} patches directory {}", side, directory)
                mkdir directory
            }
        }
    }

    // Make and apply tasks
    if (child.sourceSets == null) {
        child.makePatchesTask = task "project${child.Name}MakePatches"(type: MakePatchesTask) {
            group = 'mcplus project ' + side
            dependsOn child.decompileTask
            dependsOn child.makePatchesDirTask

            rootZip child.decompileTask.dest
            target new File(project_dir, 'src/main/java')
            patches patches_dir
        }

        child.applyPatchesTask = task "project${child.Name}ApplyPatches"(type: ApplyPatchesTask) {
            group = 'mcplus project ' + side
            dependsOn child.projectResetTask

            target child.makePatchesTask.target
            patches child.makePatchesTask.patches
        }
    } else {
        child.makePatchesTask = task "project${child.Name}MakePatches" {
            group = 'mcplus project ' + side
            description = 'Makes patches of all sourcesets in project'
        }

        child.applyPatchesTask = task "project${child.Name}ApplyPatches" {
            group = 'mcplus project ' + side
            description = 'Applies patches in all projects'
        }

        child.sourceSets.each {
            def taskSuffix = it.suffix as String
            def sourceTask = it.task as Task
            def outputDirectory = new File(project_dir, it.outputDir as String)
            def patchesDirectory = new File(patches_dir, taskSuffix as String)

            def makeTaskName = 'project' + child.Name + "MakePatches" + taskSuffix.capitalize()
            def makeTask = task "${makeTaskName}" (type: MakePatchesTask) {
                group = 'mcplus project ' + side
                dependsOn sourceTask
                dependsOn child.makePatchesDirTask

                rootZip sourceTask.dest
                target outputDirectory
                patches patchesDirectory
            }
            child.makePatchesTask.dependsOn(makeTask)

            def applyTaskName = 'project' + child.Name + "ApplyPatches" + taskSuffix.capitalize()
            def applyTask = task "${applyTaskName}" (type: ApplyPatchesTask) {
                group = 'mcplus project ' + side
                dependsOn child.projectResetTask
                dependsOn child.makePatchesDirTask

                target makeTask.target
                patches makeTask.patches
            }
            child.applyPatchesTask.dependsOn(applyTask)
        }
    }
    tasks.projectMakePatchesAll.dependsOn(child.makePatchesTask)
    tasks.projectApplyPatchesAll.dependsOn(child.applyPatchesTask)
}


/**
 * Init repositories
 */
task repositoryInitAll (group: 'mcplus repository') {
    description = 'Inits repositories in all projects'
}

/**
 * Synchronize repos
 */
task repositorySyncAll (group: 'mcplus repository') {
    description = 'Synchronizes distro repositories with JOINED'
}

configs.each { side, child ->
    def project_dir = project.file(PATH_PROJECTS + side)

    child.repoInitTask = task "repository${child.Name}Init"(type: InitRepository) {
        group = 'mcplus repository ' + side
        dependsOn child.projectCreateTask
        dependsOn child.applyPatchesTask

        target = project_dir
    }
    tasks.repositoryInitAll.dependsOn(child.repoInitTask)

    /**
     * Tasks for distro (client, server) only repositories
     */
    if (['client', 'server'].contains(side)) {
        child.repoSyncTask = task "repository${child.Name}Sync"(type: SyncChanges) {
            group = 'mcplus repository ' + side
            dependsOn child.repoInitTask
            dependsOn sides.joined.repoInitTask // depend both on JOINED
            mustRunAfter sides.joined.repoInitTask

            target = child.repoInitTask.target
            remoteName = "joined"
            remoteUrl = project_dir.relativePath(sides.joined.repoInitTask.target)
        }
        tasks.repositorySyncAll.dependsOn(child.repoSyncTask)
    }
}

/**
 * Overbuild everything
 *
 * Run this task to build everything needed to result in ready to go
 * project with output binaries built
 */
task buildAll {
    group = 'mcplus build'
    description = 'Builds everything'
    dependsOn tasks.build
    dependsOn tasks.repositoryInitAll
    dependsOn tasks.repositorySyncAll
    project.subprojects.each {sub ->
        dependsOn sub.getTasksByName('build', false)
    }
}


subprojects { Project subproject ->

    def distConfig = Utils.distributionConfig(CONFIG, subproject.name)

    /**
     * Configure downloadable artifact in JSON version manifest
     */
    if (distConfig.artifact?.downloadable) {
        def artifactTask = distConfig.artifact.shaded ? subproject.tasks.shadowJar : subproject.tasks.jar
        if (artifactTask) {
            rootProject.tasks.generateVersionJsonMeta.configure {
                download subproject.name, artifactTask.archiveFile.get().asFile
                dependsOn artifactTask // Depend on that task
            }
        }
    }

    /**
     * Configure runnables for testing purposes
     */
    def prefix =  distConfig.runnables?.size() > 1 ? subproject.name : ''
    distConfig.runnables?.each { name, config ->

        def workingDir = subproject.file("build/run/${name}/")

        def taskName = 'run' + prefix.capitalize() + name.capitalize()
        def runTask = task "${taskName}" (type: RunApplication) {
            group = "mcplus run"
            description = "Run ${subproject.name} ${name} application"
            dependsOn subproject.tasks.classes
//            dependsOn rootProject.tasks.generateVersionJsonMeta
//            dependsOn config.assets ? [project(":resources").tasks.generateAssets] : []

            doFirst {
                mkdir workingDir
            }

            type = config.type
            classpath = subproject.sourceSets.main.runtimeClasspath
            mainClass = config.mainclass
            args = config.args?.application ?: []
            jvmArgs = config.args?.jvm ?: []
            workDir workingDir

            if (config?.type == "CLIENT" ?: false) {
                dependsOn rootProject.tasks.generateVersionJsonMeta
                manifest rootProject.tasks.generateVersionJsonMeta.manifestFull
            }

            if ((config?.assets ?: false) && findProject(':resources') != null) {
                dependsOn project(":resources").tasks.generateAssets
                assets new File(project(":resources").PATH_BUILD_ASSETS).absolutePath
                index project(":resources").INDEX_ID
            }

            if (config?.natives ?: false) {
                dependsOn rootProject.tasks.extractNatives
                systemProperty "java.library.path", rootProject.tasks.extractNatives.dest.absolutePath
            }
        }
    }
}
