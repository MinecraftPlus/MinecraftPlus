buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url = 'https://plugins.gradle.org/m2/' }
        maven { url = 'https://maven.minecraftplus.org/'}
        maven { url = 'https://maven.minecraftforge.net/'}
    }
    dependencies {
        classpath 'org.minecraftplus:srgutils:0.4.29'
    }
}

plugins {
    id 'java'
    id 'de.undercouch.download'
    id 'uk.jamierocks.propatcher' version '2.0.1' apply false
    id 'org.barfuin.gradle.taskinfo' version '1.0.5'
}

repositories {
    mavenCentral()
    mavenLocal()
}

dependencies {
}

group = "org.minecraftplus"
version = "0.0.1-SNAPSHOT"



import org.minecraftplus.gradle.*
import net.minecraftforge.mcpconfig.tasks.*
import uk.jamierocks.propatcher.task.*

net.minecraftforge.mcpconfig.tasks.Utils.init()

project.ext {
    PATH_BUILD = file('build').absolutePath + '/'
    PATH_PROJECT = file('version').absolutePath + '/'
    PATH_LIBRARIES = PATH_BUILD + 'libraries/'

    PATH_PROJECTS = file('projects').absolutePath + '/'
    PATH_PROJECTS_ASSETS = PATH_PROJECTS + 'assets'
    PATH_PROJECTS_NATIVES = PATH_PROJECTS + 'natives'

    CONFIG = file(PATH_PROJECT + 'config.json').json

    MINECRAFT_VERSION = CONFIG.get('minecraft_version', '1.15.2')
    JAVA_TARGET = CONFIG.get('java_target', 8)

    FERNFLOWER = Utils.readConfig(CONFIG, 'fernflower', [
            version: 'net.minecraftforge:forgeflower:1.5.498.22',
            args: ["-din=1", "-rbr=1", "-dgs=1", "-asc=1", "-rsy=1", "-iec=1", "-isl=0", "-log=TRACE", "-cfg", "{libraries}", "{input}", "{output}"],
            jvmargs: ["-Xmx4G"]
    ])
    MERGETOOL = Utils.readConfig(CONFIG, 'merge', [
            version: 'net.minecraftforge:mergetool:1.1.3:fatjar',
            args: ["--client", "{client}", "--server", "{server}", "--ann", "{version}", "--output", "{output}"]
    ])
    RENAMETOOL = Utils.readConfig(CONFIG, 'rename', [
            version: 'org.minecraftplus:vignette:0.3.0.0',
            args: ["--jar-in", "{input}", "--jar-out", "{output}", "--mapping-format", "tsrg2", "--mappings", "{mappings}", "--cfg", "{libraries}", "--deduce-param-names", "--dictionary", "{dictionary}", "--create-inits", "--fernflower-meta"]
    ])
}

java.toolchain {
    languageVersion = JavaLanguageVersion.of(JAVA_TARGET)
}



task downloadMergeTool(group: 'download', type: DownloadTool) {
    description = 'Downloads merge tool'

    config MERGETOOL, PATH_LIBRARIES
}
task downloadRenameTool(group: 'download', type: DownloadTool) {
    description = 'Downloads rename tool'

    config RENAMETOOL, PATH_LIBRARIES
}
task downloadFernflower(group: 'download', type: DownloadTool) {
    description = 'Downloads decompiler'

    config FERNFLOWER, PATH_LIBRARIES
}

task downloadManifest(type: Download) {
    group = 'download'
    description = 'Downloads version manifest from mojang.com.'

    src 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    dest file(PATH_BUILD + 'version/manifest.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

task downloadVersionJson(type: Download) {
    group = 'download'
    description = 'Downloads minecraft version JSON configuration.'
    dependsOn rootProject.downloadManifest

    inputs.file rootProject.downloadManifest.dest
    src { downloadManifest.dest.json.versions.find{ it.id == MINECRAFT_VERSION }.url }
    dest file(PATH_BUILD + 'version/version.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}

/**
 * Download client and server JARs
 */
task downloadVersionJars(group: 'download') {
    description = 'Downloads minecraft version jars (client and server).'
}

['client', 'server'].each { id ->
    def taskName = 'downloadVersion' + id.capitalize() + "Jar"
    def versionTask = task "${taskName}" (type: Download) {
        group = 'download' + id
        dependsOn downloadVersionJson

        inputs.file downloadVersionJson.dest
        src { downloadVersionJson.dest.json.downloads.get(id).url }
        dest file(PATH_BUILD + 'version/' + id + '.jar')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    downloadVersionJars.dependsOn(versionTask)
}

/**
 * Download version libraries
 */
task downloadVersionLibraries(type: DownloadLibraries) {
    group = 'download'
    description = 'Downloads libraries needed by game version.'
    dependsOn downloadVersionJson

    json = downloadVersionJson.dest
    config = CONFIG // TODO check what we need
    dest = file(PATH_LIBRARIES)
}

/**
 * Download client assets
 */
task downloadVersionAssets(type: DownloadAssets) {
    group = 'download'
    description = 'Downloads assets used by game version.'
    dependsOn downloadVersionJson

    json = downloadVersionJson.dest
    dest = file(PATH_BUILD + '/assets/')
}


/**
 * Download official mappings for client and server
 */
task downloadMappings(group: 'download') {
    description = 'Downloads official mappings.'
}

['client', 'server'].each { side ->
    def taskName = 'download' + side.capitalize() + "Mappings"
    def mappingsTask = task "${taskName}" (type: Download) {
        group = 'process' + side
        dependsOn downloadVersionJson

        inputs.file downloadVersionJson.dest
        src { downloadVersionJson.dest.json.downloads.get(side + '_mappings').url }
        dest file(PATH_BUILD + 'mappings/' + side + '_mappings.txt')
        useETag 'all'
        onlyIfModified true
        quiet true
    }
    downloadMappings.dependsOn(mappingsTask)
}

/**
 * Convert official mappings to TSRG2 format
 */
task convertMappings(group: 'process') {
    description = 'Converts official mappings to TSRG format.'
}

['client', 'server'].each { side ->
    def taskName = 'convert' + side.capitalize() + "Mappings"
    def convertTask = task "${taskName}" (type: ConvertMappings) {
        group = 'process' + side
        dependsOn tasks.getByPath("download${side.capitalize()}Mappings")

        input =  tasks.getByPath("download${side.capitalize()}Mappings").dest
        dest = file(PATH_BUILD + 'mappings/' + side + '_mappings.tsrg')
    }
    convertMappings.dependsOn(convertTask)
}


/**
 * Filter version jars to contain only classes
 */
task filterVersionJars(group: 'process') {
    description = 'Filters version jars.'
}

['client', 'server'].each { side ->
    def taskName = 'filterVersion' + side.capitalize() + "Jar"
    def filterTask = task "${taskName}" (type: SplitJar) {
        group = 'process' + side
        dependsOn tasks.getByPath("convert${side.capitalize()}Mappings")
        dependsOn tasks.getByPath("downloadVersion${side.capitalize()}Jar")

        input = tasks.getByPath("downloadVersion${side.capitalize()}Jar").dest
        mappings = tasks.getByPath("convert${side.capitalize()}Mappings").dest
        acceptable = [ "assets/", "data/", "net/minecraft/", "com/mojang/blaze3d", "com/mojang/realms",
                       "log4j2.xml", "pack.mcmeta", "pack.png", "version.json" ]
        sources = file(PATH_BUILD + 'version/' + side + '.sources.jar')
        resources = file(PATH_BUILD + 'version/' + side + '.resources.jar')
        libraries = file(PATH_BUILD + 'version/' + side + '.libraries.jar')
    }
    filterVersionJars.dependsOn(filterTask)
}


/**
 * Merge client and server JAR to one annotated with @OnlyIn(Dist.<SIDE>)
 */
task mergeVersionJars(type: MergeJar) {
    group = 'process'
    description = 'Merges source JARs into one annotated with Dist marker.'
    dependsOn downloadMergeTool
    dependsOn filterVersionClientJar
    dependsOn filterVersionServerJar

    config MERGETOOL, downloadMergeTool
    client filterVersionClientJar.sources
    server filterVersionServerJar.sources
    dest file(PATH_BUILD + 'version/joined.jar')
    annotations 'API'
}


/**
 * Process sides configuration
 */
def sides = [
    joined: [Name: 'Joined', jsonlibs: true,  extra: 'Client', assets: true,
             mappingsTask: convertClientMappings,
             splitTask: mergeVersionJars,
             resources: [filterVersionClientJar.resources, filterVersionServerJar.resources],
             bundle: null],
    client: [Name: 'Client', jsonlibs: true,  extra: 'Client', assets: true,
             mappingsTask: convertClientMappings,
             splitTask: filterVersionClientJar,
             resources: [filterVersionClientJar.resources],
             bundle: null],
    server: [Name: 'Server', jsonlibs: false, extra: 'Server', assets: false,
             mappingsTask: convertServerMappings,
             splitTask: filterVersionServerJar,
             resources: [filterVersionServerJar.resources],
             bundle: downloadVersionServerJar]
]


/**
 * Prepare list of libraries for Vignette and Fernflower
 */
task generateProcessLibraries(group: 'process') {
    description = 'Renames jars using mappings'
}

sides.each { s, child ->
    def taskName = 'generateProcess' + child.Name + 'Libraries'
    child.librariesTask = task "${taskName}" (type: CreateFernflowerLibraries) {
        group = 'process' + s
        dependsOn downloadVersionLibraries
        dependsOn downloadVersionJson
        dependsOn child.splitTask

        meta = downloadVersionJson.dest
        config = CONFIG
        side = s
        root = file(PATH_LIBRARIES)
        dest file(PATH_BUILD + 'mapped/' + s + '.fernflower.libs.txt')
    }
    generateProcessLibraries.dependsOn(child.librariesTask)
}

/**
 * Vignette renaming
 */
task renameVersionJars(group: 'process') {
    description = 'Renames jars using mappings'
}

sides.each { side, child ->
    def taskName = 'renameVersion' + child.Name + 'Jar'
    child.renameTask = task "${taskName}" (type: RemapJar) {
        group = 'process' + side
        dependsOn downloadRenameTool
        dependsOn child.splitTask
        dependsOn child.mappingsTask
        dependsOn child.librariesTask

        config RENAMETOOL, downloadRenameTool
        input = 'joined'.equals(side) ? child.splitTask.dest : child.splitTask.sources // Use dest if input is from MergeJars
        mappings = child.mappingsTask.dest
        libraries = child.librariesTask.dest
        dictionary = file(PATH_PROJECT + 'dictionary.dict')
        dest = file(PATH_BUILD + 'mapped/' + side + '.mapped.jar')
        log = file(PATH_BUILD + 'mapped/' + side + '.mapped.log')
    }
    renameVersionJars.dependsOn(child.renameTask)
}

/**
 * Fernflower decompilation
 */
task decompileVersionJars (group: 'process') {
    description = 'Decompiles jars'
}

sides.each { side, child ->
    def taskName = 'decompileVersion' + child.Name + 'Jar'
    child.decompileTask = task "${taskName}" (type: FernflowerTask) {
        group = 'process' + side
        dependsOn downloadFernflower
        dependsOn child.librariesTask
        dependsOn child.renameTask

        config FERNFLOWER, downloadFernflower
        javaLauncher = javaToolchains.launcherFor {
            languageVersion = JavaLanguageVersion.of(JAVA_TARGET)
        }
        libraries = child.librariesTask.dest
        input = child.renameTask.dest

        log = file(PATH_BUILD + '/decompile/' + side + '.decompile.log')
        dest = file(PATH_BUILD + '/decompile/' + side + '.decompile.jar')
    }
    decompileVersionJars.dependsOn(child.decompileTask)
}




task createProjectsRoot(type: Copy) {
    group = 'project'

    from rootProject.file('templates/root_settings.gradle')
    into file('projects/')
    rename { 'settings.gradle' }
    expand([version: project.name])
}

task extractNatives(type: ExtractNatives) {
    group = 'project'
    dependsOn downloadVersionJson
    dependsOn downloadVersionLibraries

    meta downloadVersionJson.dest
    cache file(PATH_LIBRARIES)
    dest file(PATH_PROJECTS_NATIVES)
}



/**
 * Apply patches
 */
task projectApplyPatches (group: 'project') {
    description = 'Applies patches to projects'
}

/**
 * Init repositories
 */
task repositoryInits (group: 'repository') {
    description = 'Inits repositories in all projects'
}

sides.each { side, child ->
    def project_dir = project.file("projects/${side}")
    def patches_dir = project.file("src/patches/${side}")


    child.projectTask = task "project${child.Name}"(type: CreateProjectTemplate) {
        group = 'project' + side

        dependsOn createProjectsRoot
//        dependsOn child.splitTask
        dependsOn child.decompileTask
//        dependsOn child.pkgs
        dependsOn(child.jsonlibs ? [downloadVersionJson, extractNatives] : [])
        dependsOn(child.assets ? [downloadVersionAssets] : [])
//        dependsOn (child.bundle != null ? [child.bundle] : [])

//        mustRunAfter child.delete

        dest project_dir
        distro side
        template rootProject.file('templates/build.gradle')
        if (child.jsonlibs)
            meta downloadVersionJson.dest
        if (child.bundle != null)
            bundle = child.bundle.dest
        CONFIG?.libraries?.get(side)?.each { library "'${it}'" }

        if (child.resources != null)
            child.resources.each { res -> libraryFile res }

        //libraryFile child.splitTask.libraries

        replace '{java_target}', JAVA_TARGET + ''
        //replaceFile '{inject}', PATH_INJECT
        replaceFile '{assets}', child.assets ? downloadVersionAssets.dest : null
        replaceFile '{natives}', child.jsonlibs ? extractNatives.dest : null
        //replaceFile '{merged_src}', MERGE_PATCHES ? projectSharedReset.target : null

        doLast {
            def directory = new File(project_dir, 'src/main/java')
            System.out.println("Creating directory " + directory)
            mkdir directory
        }
    }

    child.resetTask = task "project${child.Name}Reset"(type: ResetSourcesTask) {
        group = 'project' + side
//        dependsOn child.resetPkgs
//        dependsOn child.makeSrcDir
        dependsOn child.projectTask
        dependsOn child.decompileTask

//        mustRunAfter child.project

        rootZip child.decompileTask.dest
        target new File(project_dir, 'src/main/java')
    }

    child.makePatchesDir = task "project${child.Name}MakePatchesDir"() {
        group = 'project' + side
        doLast {
            mkdir patches_dir
        }
    }

    child.apply = task "project${child.Name}ApplyPatches"(type: ApplyPatchesTask) {
        group = 'project' + side
        dependsOn child.resetTask
        dependsOn child.makePatchesDir

        target new File(project_dir, 'src/main/java')
        patches patches_dir
    }
    projectApplyPatches.dependsOn(child.apply)

    child.makePatches = task "project${child.Name}MakePatches"(type: MakePatchesTask) {
        group = 'project' + side
        dependsOn child.decompileTask
        dependsOn child.makePatchesDir
        //dependsOn MERGE_PATCHES ? [deduplicateSources, projectSharedMakePatches]

        rootZip child.decompileTask.dest
        target new File(project_dir, 'src/main/java')
        patches patches_dir
    }


//    task cloneGitRepo(type: GitClone) {
//        group = 'repository' + side
//
//
//        def destination = file("destination_folder")
//        uri = "your_git_repo_uri"
//        destinationPath = destination
//        bare = false
//        enabled = !destination.exists() //to clone only once
//    }

    child.repoInitTask = task "repository${child.Name}Init"(type: InitRepository) {
        group = 'repository' + side

        target = project_dir
        lock = new File(project_dir, '.freshinit')
    }
    repositoryInits.dependsOn(child.repoInitTask)

    /**
     * Configure repositories of distro releases
     *  - it adds a remote to joined source on master branch
     */
    if (!side.equals('joined')) {
//        child.repoAddRemoteTask = task "repository${child.Name}Config"(type: ConfigDistroRepository) {
//            group = 'repository' + side
//            dependsOn child.repoInitTask
//            dependsOn sides.joined.repoInitTask
//            mustRunAfter sides.joined.repoInitTask
//
//            target = child.repoInitTask.target
//            remoteName = "joined"
//            remoteUrl = project_dir.relativePath(sides.joined.repoInitTask.target)
//        }

        child.repoSyncTask = task "repository${child.Name}Sync"(type: SyncChanges) {
            group = 'repository' + side
            dependsOn child.repoInitTask
            dependsOn sides.joined.repoInitTask
            mustRunAfter sides.joined.repoInitTask

            target = child.repoInitTask.target
            if (child.repoInitTask.lock?.exists())
                freshinit = child.repoInitTask.lock
            remoteName = "joined"
            remoteUrl = project_dir.relativePath(sides.joined.repoInitTask.target)
        }
    }
}
