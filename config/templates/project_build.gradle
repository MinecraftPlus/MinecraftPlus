plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'checkstyle'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'org.minecraftplus.gradle.assetator' version '0.1.0'
}

repositories {
    mavenCentral()
    maven {
        name 'minecraft'
        url 'https://libraries.minecraft.net/'
    }
    maven {
        name 'minecraftplus'
        url 'https://maven.minecraftplus.org/'
    }
    maven {
        name 'forge'
        url 'https://maven.minecraftforge.net/'
    }
}

configurations {
    all {
        transitive = false
    }

    server {
        description = 'Contains server dependencies'
    }
    serverImplementation.extendsFrom implementation

    client {
        description = 'Contains client dependencies'
        extendsFrom server
    }
    clientImplementation.extendsFrom client

    implementation.extendsFrom server, client

    checkstyle {
        transitive = true
    }
}

dependencies {
    {libraries}
}


import org.minecraftplus.gradle.tasks.Utils
import org.minecraftplus.gradle.tasks.meta.GenerateVersionInfo
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.time.ZonedDateTime

Utils.init() // Initialize special gradle utils

ext {
    CONFIG = rootProject.ext.CONFIG // Load and use config from root project
    DIST_CONFIG = Utils.projectConfig(CONFIG)

    JAVA = CONFIG.java_target ?: 8

    INDEX_ID = DIST_CONFIG.index
    PATH_BUILD = file('build').absolutePath + '/'
    PATH_BUILD_ASSETS = PATH_BUILD + 'assets/'
}

group = rootProject.group
version = rootProject.version

sourceSets {
    remote {
        resources.srcDirs = ['src/main/resources/remote']
    }
    internal {
        resources.srcDirs = ['src/main/resources/internal']
    }
    shared {
        resources {
            srcDirs = ['src/main/resources/internal', 'build/resources/generated']

            // Resources shared between client and server
            include "assets/.mcassetsroot"
            include "data/**"
            include "log4j2.xml"
            include "pack.mcmeta"
            include "version.json"
        }
    }
    client {
        java {
            srcDir sourceSets.main.java.srcDirs
        }
        resources {
            srcDirs = ['src/main/resources/internal']
            setIncludes shared.resources.getIncludes()

            // Resources special to client
            include "assets/**"
            include "pack.png"
        }
    }
    server {
        java {
            srcDir sourceSets.main.java.srcDirs

            exclude "net/minecraft/client"
            exclude "net/minecraft/realms"
            exclude "com/mojang/realmsclient"
            exclude "com/mojang/blaze3d"
        }
        resources {
            srcDirs = ['src/main/resources/internal']
            setIncludes shared.resources.getIncludes()

            // Resources special to server
            include "assets/minecraft/lang/en_us.json"
            include "Log4j-config.xsd"
            include "Log4j-events.dtd"
            include "Log4j-events.xsd"
            include "Log4j-levels.xsd"
        }
    }
    main {
        resources.srcDirs = shared.resources.srcDirs
    }
}

java.toolchain.languageVersion = JavaLanguageVersion.of(JAVA)

checkstyle {
    toolVersion = '8.2'
    configFile file(rootProject.PATH_CONFIG + "/checkstyle.xml")
}

archivesBaseName = String.join('-', rootProject.name, project.name)

task serverJar(type: ShadowJar) {
    archiveClassifier.set('server')
    manifest {
        attributes 'version': project.version
        attributes 'javaCompliance': project.targetCompatibility
        attributes 'group': project.group
        attributes 'Main-Class': DIST_CONFIG.runnables.server.mainclass
    }

    from sourceSets.server.output
    configurations = [project.configurations.server]
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Filter META-INF stuff from dependencies
    exclude 'META-INF/versions/**'
    exclude 'META-INF/maven/**'
    exclude 'META-INF/org/**'
    exclude 'META-INF/services/**'
    exclude 'META-INF/eclipse.inf'
    exclude 'META-INF/ECLIPSE_.*'
    exclude 'META-INF/DEPENDENCIES**'
    exclude 'META-INF/LICENSE**'
    exclude 'META-INF/NOTICE**'
}

task clientJar(type: ShadowJar) {
    archiveClassifier.set('client')
    manifest {
        attributes 'version': project.version
        attributes 'javaCompliance': project.targetCompatibility
        attributes 'group': project.group
        attributes 'Main-Class': DIST_CONFIG.runnables.client.mainclass
    }

    from sourceSets.client.output
}

task jar(type: ShadowJar, overwrite: true) {
    archiveClassifier.set('bundle')
    manifest {
        attributes 'version': project.version
        attributes 'javaCompliance': project.targetCompatibility
        attributes 'group': project.group
    }

    configurations = [project.configurations.server, project.configurations.client]
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task sourcesJar(type: Jar, dependsOn: classes) {
    group = 'build'
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    group = 'build'
    classifier = 'javadoc'
    from javadoc.destinationDir
}


artifacts {
    archives serverJar
    archives clientJar
    archives sourcesJar
    archives javadocJar
}


assets {
    generate {
        input = sourceSets.remote.resources.srcDirs as File[]
        output = file(PATH_BUILD_ASSETS + 'indexes/' + INDEX_ID + '.json')
        objectsDir = file(PATH_BUILD_ASSETS + 'objects/')
    }
}

/**
 * Generate version.json information file with project variables
 */
def genTask = task generateVersionJson(type: GenerateVersionInfo) {
    def versionInfo = Utils.versionInfo(CONFIG)

    id = versionInfo.id
    release_name = versionInfo.name
    release_target = versionInfo.release_target
    world_version = versionInfo.world_version
    protocol_version = versionInfo.protocol_version
    pack_version = versionInfo.pack_version
    // Update build timestamp only if in production mode - skip unnecessary resource processing
    if (rootProject.ext.PRODUCTION_MODE)
        build_time = ZonedDateTime.now()
    stable = versionInfo.id.endsWith("SNAPSHOT") ? false : true

    output = file('build/resources/generated/version.json')
}
tasks.withType(ProcessResources) {
    dependsOn(genTask)
}


/*
 * Miscellaneous, not much important
 */

// Group some task in more meaningful groups
tasks.withType(Checkstyle) {
    group = 'checkstyle'
}
tasks.findAll { it.name.containsIgnoreCase('eclipse') }.each { task ->
    task.group = 'eclipse'
}
