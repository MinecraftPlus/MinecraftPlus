plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'checkstyle'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'org.minecraftplus.gradle.assetator' version '0.1.0'
}

repositories {
    mavenCentral()
    maven {
        name 'minecraft'
        url 'https://libraries.minecraft.net/'
    }
    maven {
        name 'minecraftplus'
        url 'https://maven.minecraftplus.org/'
    }
    maven {
        name 'forge'
        url 'https://maven.minecraftforge.net/'
    }
}

configurations {
    all {
        transitive = false
    }
    checkstyle {
        transitive = true
    }
}

dependencies {
    {libraries}
}


import org.minecraftplus.gradle.tasks.Utils
import org.minecraftplus.gradle.tasks.meta.GenerateVersionInfo

import java.time.ZonedDateTime

// Generating timestamp

Utils.init() // Initialize special gradle utils

ext {
    CONFIG = rootProject.ext.CONFIG // Load and use config from root project
    DIST_CONFIG = Utils.projectConfig(CONFIG)

    DISTRO = project.name
    JAVA = CONFIG.java_target ?: 8
    RESOURCES = DIST_CONFIG.resources ?: 'internal'
    SHADE = DIST_CONFIG.artifact.shaded ?: false
    MAIN_CLASS = DIST_CONFIG.artifact.mainclass ?: null

    INDEX_ID = DIST_CONFIG.index
    PATH_BUILD = file('build').absolutePath + '/'
    PATH_BUILD_ASSETS = PATH_BUILD + 'assets/'
}

group = rootProject.group
version = rootProject.version

archivesBaseName = String.join('-', rootProject.name, project.name)

sourceSets {
    remote {
        resources.srcDirs = ['src/main/resources/remote']
    }
    internal {
        resources.srcDirs = ['src/main/resources/internal']
    }
    shared {
        resources {
            srcDirs = ['src/main/resources/internal']

            // Resources shared between client and server
            include "assets/.mcassetsroot"
            include "data/**"
            include "log4j2.xml"
            include "pack.mcmeta"
            include "version.json"
        }
    }
    client {
        resources {
            srcDirs = ['src/main/resources/internal']
            setIncludes shared.resources.getIncludes()

            // Resources special to client
            include "assets/**"
            include "pack.png"
        }
    }
    server {
        resources {
            srcDirs = ['src/main/resources/internal']
            setIncludes shared.resources.getIncludes()

            // Resources special to server
            include "assets/minecraft/lang/en_us.json"
            include "Log4j-config.xsd"
            include "Log4j-events.dtd"
            include "Log4j-events.xsd"
            include "Log4j-levels.xsd"
        }
    }
    main {
        resources {
            def resourceSet = sourceSets['internal'].resources
            srcDir resourceSet.srcDirs
            srcDir 'build/resources/generated'
            setIncludes resourceSet.getIncludes()
        }
    }
}

java.toolchain.languageVersion = JavaLanguageVersion.of(JAVA)

checkstyle {
    toolVersion = '8.2'
    configFile file(rootProject.PATH_CONFIG_CHECKSTYLE + DISTRO + "/checkstyle.xml")
}

jar {
    manifest {
        attributes 'version': project.version
        attributes 'javaCompliance': project.targetCompatibility
        attributes 'group': project.group
        if (MAIN_CLASS) {
            attributes 'Main-Class': MAIN_CLASS
        }
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    group = 'build'
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    group = 'build'
    classifier = 'javadoc'
    from javadoc.destinationDir
}

if (SHADE) {
    apply plugin: 'com.github.johnrengelman.shadow'
    shadowJar {
        classifier = 'bundle'
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        // Filter META-INF stuff from dependencies
        exclude 'META-INF/versions/**'
        exclude 'META-INF/maven/**'
        exclude 'META-INF/org/**'
        exclude 'META-INF/services/**'
        exclude 'META-INF/eclipse.inf'
        exclude 'META-INF/ECLIPSE_.*'
        exclude 'META-INF/DEPENDENCIES**'
        exclude 'META-INF/LICENSE**'
        exclude 'META-INF/NOTICE**'
    }
}

artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
    if (SHADE) {
        archives shadowJar
    }
}

assets {
    generate {
        input = sourceSets.remote.resources.srcDirs as File[]
        output = file(PATH_BUILD_ASSETS + 'indexes/' + INDEX_ID + '.json')
        objectsDir = file(PATH_BUILD_ASSETS + 'objects/')
    }
}

/**
 * Generate version.json information file with project variables
 */
def genTask = task generateVersionJson(type: GenerateVersionInfo) {
    def versionInfo = Utils.versionInfo(CONFIG)

    id = versionInfo.id
    release_name = versionInfo.name
    release_target = versionInfo.release_target
    world_version = versionInfo.world_version
    protocol_version = versionInfo.protocol_version
    pack_version = versionInfo.pack_version
    // Update build timestamp only if in production mode - skip unnecessary resource processing
    if (rootProject.ext.PRODUCTION_MODE)
        build_time = ZonedDateTime.now()
    stable = versionInfo.id.endsWith("SNAPSHOT") ? false : true

    output = file('build/resources/generated/version.json')
}
tasks.processResources.dependsOn(genTask)


/*
 * Miscellaneous, not much important
 */

// Group some task in more meaningful groups
tasks.withType(Checkstyle) {
    group = 'checkstyle'
}
tasks.findAll { it.name.containsIgnoreCase('eclipse') }.each { task ->
    task.group = 'eclipse'
}
