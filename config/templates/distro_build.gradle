buildscript {
    dependencies {
        if (findProject(':resources') != null) {
            classpath rootProject.project(':resources')
        }
    }
}

plugins {
    id 'java'
    id 'eclipse'
    id 'idea'
    id 'checkstyle'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
}

repositories {
    mavenCentral()
    maven {
        name 'minecraft'
        url 'https://libraries.minecraft.net/'
    }
    maven {
        name 'minecraftplus'
        url 'https://maven.minecraftplus.org/'
    }
    maven {
        name 'forge'
        url 'https://maven.minecraftforge.net/'
    }
}

configurations {
    all {
        transitive = false
    }
    checkstyle {
        transitive = true
    }
}

dependencies {
    {libraries}
}

import org.minecraftplus.gradle.tasks.Utils
import org.minecraftplus.gradle.tasks.meta.GenerateVersionInfo
// Generating timestamp
import java.time.ZonedDateTime

Utils.init() // Initialize special gradle utils

ext {
    CONFIG = rootProject.ext.CONFIG // Load and use config from root project
    DIST_CONFIG = Utils.projectConfig(CONFIG)

    DISTRO = project.name
    JAVA = CONFIG.java_target ?: 8
    RESOURCES = DIST_CONFIG.resources ?: 'internal'
    SHADE = DIST_CONFIG.artifact.shaded ?: false
    MAIN_CLASS = DIST_CONFIG.artifact.mainclass ?: null
}

group = rootProject.group
version = rootProject.version

archivesBaseName = String.join('-', rootProject.name, project.name)

sourceSets {
    main {
        if (findProject(':resources') != null) {
            resources {
                def resourceSet = project(":resources").sourceSets[RESOURCES as String].resources
                srcDir resourceSet.srcDirs
                srcDir 'build/resources/generated'
                setIncludes resourceSet.getIncludes()
            }
        }
    }
}

java.toolchain.languageVersion = JavaLanguageVersion.of(JAVA)

checkstyle {
    toolVersion = '8.2'
    configFile file(rootProject.PATH_CONFIG_CHECKSTYLE + DISTRO + "/checkstyle.xml")
}

jar {
    manifest {
        attributes 'version': project.version
        attributes 'javaCompliance': project.targetCompatibility
        attributes 'group': project.group
        if (MAIN_CLASS) {
            attributes 'Main-Class': MAIN_CLASS
        }
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    group = 'build'
    classifier = 'sources'
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    group = 'build'
    classifier = 'javadoc'
    from javadoc.destinationDir
}

if (SHADE) {
    apply plugin: 'com.github.johnrengelman.shadow'
    shadowJar {
        classifier = 'bundle'
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        // Filter META-INF stuff from dependencies
        exclude 'META-INF/versions/**'
        exclude 'META-INF/maven/**'
        exclude 'META-INF/org/**'
        exclude 'META-INF/services/**'
        exclude 'META-INF/eclipse.inf'
        exclude 'META-INF/ECLIPSE_.*'
        exclude 'META-INF/DEPENDENCIES**'
        exclude 'META-INF/LICENSE**'
        exclude 'META-INF/NOTICE**'
    }
}

artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
    if (SHADE) {
        archives shadowJar
    }
}

/**
 * Generate version.json information file with project variables
 */
def genTask = task generateVersionJson (type: GenerateVersionInfo) {
    def versionInfo = Utils.versionInfo(CONFIG)

    id = versionInfo.id
    release_name = versionInfo.name
    release_target = versionInfo.release_target
    world_version = versionInfo.world_version
    protocol_version = versionInfo.protocol_version
    pack_version = versionInfo.pack_version
    // Update build timestamp only if in production mode - skip unnecessary resource processing
    if (rootProject.ext.PRODUCTION_MODE)
        build_time = ZonedDateTime.now()
    stable = versionInfo.id.endsWith("SNAPSHOT") ? false : true

    output = file('build/resources/generated/version.json')
}
tasks.processResources.dependsOn(genTask)


/*
 * Miscellaneous, not much important
 */

// Group some task in more meaningful groups
tasks.withType(Checkstyle) {
    group = 'checkstyle'
}
tasks.findAll {it.name.containsIgnoreCase('eclipse') }.each { task ->
    task.group = 'eclipse'
}

