--- /dev/null
+++ b/net/minecraft/world/entity/vehicle/Cannon.java
@@ -0,0 +1,954 @@
+package net.minecraft.world.entity.vehicle;
+
+import java.util.List;
+import javax.annotation.Nullable;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NbtUtils;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.syncher.EntityDataAccessor;
+import net.minecraft.network.syncher.EntityDataSerializers;
+import net.minecraft.network.syncher.SynchedEntityData;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.sounds.SoundEvents;
+import net.minecraft.util.Mth;
+import net.minecraft.world.Container;
+import net.minecraft.world.ContainerListener;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.MenuProvider;
+import net.minecraft.world.SimpleContainer;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntitySelector;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.MoverType;
+import net.minecraft.world.entity.Pose;
+import net.minecraft.world.entity.animal.Animal;
+import net.minecraft.world.entity.animal.IronGolem;
+import net.minecraft.world.entity.player.Inventory;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.Cannonball;
+import net.minecraft.world.inventory.AbstractContainerMenu;
+import net.minecraft.world.inventory.CannonMenu;
+import net.minecraft.world.inventory.MenuType;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.GameRules;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import net.minecraftforge.api.distmarker.Dist;
+import net.minecraftforge.api.distmarker.OnlyIn;
+
+public class Cannon extends Entity implements ContainerListener, MenuProvider
+{
+    private static final EntityDataAccessor<Integer> DATA_ID_HURT = SynchedEntityData.<Integer>defineId(Cannon.class,
+        EntityDataSerializers.INT);
+    private static final EntityDataAccessor<Integer> DATA_ID_HURTDIR = SynchedEntityData.<Integer>defineId(Cannon.class,
+        EntityDataSerializers.INT);
+    private static final EntityDataAccessor<Float> DATA_ID_DAMAGE = SynchedEntityData.<Float>defineId(Cannon.class,
+        EntityDataSerializers.FLOAT);
+
+    private static final EntityDataAccessor<Integer> DATA_ID_DISPLAY_BLOCK = SynchedEntityData.defineId(Cannon.class,
+        EntityDataSerializers.INT);
+    private static final EntityDataAccessor<Integer> DATA_ID_DISPLAY_OFFSET = SynchedEntityData.defineId(Cannon.class,
+        EntityDataSerializers.INT);
+    private static final EntityDataAccessor<Boolean> DATA_ID_CUSTOM_DISPLAY = SynchedEntityData.defineId(Cannon.class,
+        EntityDataSerializers.BOOLEAN);
+
+    private static final EntityDataAccessor<Boolean> DATA_ISREADY = SynchedEntityData.defineId(Cannon.class,
+        EntityDataSerializers.BOOLEAN);
+
+    /** Cannon inventory for explosives and bullet */
+    protected SimpleContainer inventory;
+
+    /** Barrel angle */
+    private float deltaXRotation;
+    private float deltaYRotation;
+
+    /** Progress of the cannon turn */
+    private int lerpSteps;
+    private double lerpX;
+    private double lerpY;
+    private double lerpZ;
+    private double lerpYRot;
+    private double lerpXRot;
+    @OnlyIn(Dist.CLIENT)
+    private double lerpXDelta;
+    @OnlyIn(Dist.CLIENT)
+    private double lerpYDelta;
+    @OnlyIn(Dist.CLIENT)
+    private double lerpZDelta;
+
+    private boolean inputLeft;
+    private boolean inputRight;
+    private boolean inputForward;
+    private boolean inputBackward;
+    private boolean inputSkewBarrel;
+
+    // Some movement constants
+    private final float barrelSpeed = 0.5F;
+    private final float rotationSpeed = 0.35F;
+    private final float minAngle = -17.0f;
+    private final float maxAngle = 20.0f;
+    
+    public float animationSpeed;
+    public float animationPosition;
+    public float animationPositionOld;
+
+    public Cannon(EntityType<? extends Cannon> entityType, Level level) {
+        super(entityType, level);
+        this.blocksBuilding = true;
+        this.createInventory();
+    }
+
+    public Cannon(Level level, double x, double y, double z) {
+        this(EntityType.CANNON, level);
+        this.setPos(x, y, z);
+        this.setDeltaMovement(Vec3.ZERO);
+        this.xo = x;
+        this.yo = y;
+        this.zo = z;
+    }
+
+    @Override
+    protected void defineSynchedData() {
+        this.entityData.define(DATA_ID_HURT, 0);
+        this.entityData.define(DATA_ID_HURTDIR, 1);
+        this.entityData.define(DATA_ID_DAMAGE, 0.0F);
+        this.entityData.define(DATA_ID_DISPLAY_BLOCK, Block.getId(Blocks.AIR.defaultBlockState()));
+        this.entityData.define(DATA_ID_DISPLAY_OFFSET, 6);
+        this.entityData.define(DATA_ID_CUSTOM_DISPLAY, false);
+        this.entityData.define(DATA_ISREADY, false);
+    }
+
+    /**
+     * Returns a boundingBox used to collide the entity with other entities and blocks. This enables the entity to be
+     * pushable on contact, like boats or minecarts.
+     */
+    @Nullable
+    @Override
+    public AABB getCollideAgainstBox(Entity entity) {
+        return entity.isPushable() ? entity.getBoundingBox() : null;
+    }
+
+    /**
+     * Returns the <b>solid</b> collision bounding box for this entity. Used to make (e.g.) boats solid. Return null if
+     * this entity is not solid. For general purposes, use {@link #width} and {@link #height}.
+     * 
+     * @see getEntityBoundingBox
+     */
+    @Nullable
+    @Override
+    public AABB getCollideBox() {
+        return this.getBoundingBox();
+    }
+
+    /**
+     * Returns true if this entity should push and be pushed by other entities when colliding.
+     */
+    @Override
+    public boolean isPushable() {
+        return true;
+    }
+
+    @Override
+    protected float getEyeHeight(Pose p_213316_1_, EntityDimensions p_213316_2_) {
+        return 0.85F;
+    }
+
+    /**
+     * Returns the Y offset from the entity's position for any entity riding this one.
+     */
+    @Override
+    public double getRideHeight() {
+        return 0.35D;
+    }
+
+    /**
+     * Get's the maximum speed for a cannon
+     */
+    protected double getMaxSpeed() {
+        return 0.0075D;
+    }
+
+    /**
+     * Called when the entity is attacked.
+     */
+    @Override
+    public boolean hurt(DamageSource p_70097_1_, float p_70097_2_) {
+        if (!this.level.isClientSide && !this.removed) {
+            if (this.isInvulnerableTo(p_70097_1_)) {
+                return false;
+            } else {
+                this.setHurtDir(-this.getHurtDir());
+                this.setHurtTime(10);
+                this.markHurt();
+                this.setDamage(this.getDamage() + p_70097_2_ * 10.0F);
+                boolean flag = p_70097_1_.getEntity() instanceof Player
+                    && ((Player)p_70097_1_.getEntity()).abilities.instabuild;
+                if (flag || this.getDamage() > 40.0F) {
+                    this.ejectPassengers();
+                    if (flag && !this.hasCustomName()) {
+                        this.remove();
+                    } else {
+                        this.destroy(p_70097_1_);
+                    }
+                }
+
+                return true;
+            }
+        } else {
+            return true;
+        }
+    }
+
+    /**
+     * Same as {@link #remove()} but adds entity drop
+     * 
+     * @param source damage source
+     */
+    public void destroy(DamageSource source) {
+        this.remove();
+        if (this.level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
+            ItemStack itemstack = new ItemStack(Items.CANNON);
+            if (this.hasCustomName()) {
+                itemstack.setHoverName(this.getCustomName());
+            }
+
+            this.spawnAtLocation(itemstack);
+        }
+
+    }
+
+    /**
+     * Setups the entity to do the hurt animation. Only used by packets in multiplayer.
+     */
+    @OnlyIn(Dist.CLIENT)
+    @Override
+    public void animateHurt() {
+        this.setHurtDir(-this.getHurtDir());
+        this.setHurtTime(10);
+        this.setDamage(this.getDamage() + this.getDamage() * 10.0F);
+    }
+
+    /**
+     * Returns true if other Entities should be prevented from moving through this Entity.
+     */
+    @Override
+    public boolean isPickable() {
+        return !this.removed;
+    }
+
+    /**
+     * Gets the horizontal facing direction of this Entity, adjusted to take specially-treated entity types into
+     * account.
+     */
+    @Override
+    public Direction getMotionDirection() {
+        return this.getDirection().getClockWise();
+    }
+
+    /**
+     * Called to update the entity's position/logic.
+     */
+    @Override
+    public void tick() {
+        if (this.getHurtTime() > 0) {
+            this.setHurtTime(this.getHurtTime() - 1);
+        }
+
+        if (this.getDamage() > 0.0F) {
+            this.setDamage(this.getDamage() - 1.0F);
+        }
+
+        if (this.getY() < -64.0D) {
+            this.outOfWorld();
+        }
+
+        super.tick();
+        this.tickLerp();
+        if (this.isControlledByLocalInstance()) {
+            this.moveCannon();
+            if (this.level.isClientSide) {
+                this.controlCannon();
+            }
+
+            this.move(MoverType.SELF, this.getDeltaMovement());
+        } else {
+            this.setDeltaMovement(Vec3.ZERO);
+        }
+
+        this.applyNaturalSlowdown();
+
+        this.handleNetherPortal();
+        if (this.level.isClientSide) {
+            if (!this.isNoGravity()) {
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.04D, 0.0D));
+            }
+
+            this.checkInsideBlocks();
+
+            this.setRot(this.yRot, this.xRot);
+            if (getHorizontalDistanceSqr(this.getDeltaMovement()) > 0.01D) {
+                List<Entity> list = this.level.getEntities(this,
+                    this.getBoundingBox().inflate((double)0.2F, 0.0D, (double)0.2F), EntitySelector.pushableBy(this));
+                if (!list.isEmpty()) {
+                    for (int l = 0; l < list.size(); ++l) {
+                        Entity entity1 = list.get(l);
+                        if (!(entity1 instanceof Player) && !(entity1 instanceof IronGolem)
+                            && !(entity1 instanceof Cannon) && !this.isVehicle() && !entity1.isPassenger()) {
+                            entity1.startRiding(this);
+                        } else {
+                            entity1.push(this);
+                        }
+                    }
+                }
+            } else {
+                for (Entity entity : this.level.getEntities(this,
+                    this.getBoundingBox().inflate((double)0.2F, 0.0D, (double)0.2F))) {
+                    if (!this.hasPassenger(entity) && entity.isPushable() && entity instanceof Cannon) {
+                        entity.push(this);
+                    }
+                }
+            }
+            
+            // Calculate movement for wheel rotating
+            Vec3 vector = new Vec3(this.getX() - this.xo, 0.0d, this.getZ() - this.zo);
+            float distance = (float)(vector.length() * 4.0F);
+            if (distance > 1.0F) {
+                distance = 1.0F;
+            }
+            boolean forward = vector.normalize().subtract(this.getViewVector(1.0F)).length() >= 1.0F;
+
+            this.animationPositionOld = this.animationPosition;
+            this.animationPosition += forward ? this.animationSpeed : -this.animationSpeed;
+            this.animationSpeed += (distance - this.animationSpeed) * 0.6F;
+        } else {
+            this.updateInWaterState();
+        }
+    }
+
+    private void tickLerp() {
+        if (this.isControlledByLocalInstance()) {
+            this.lerpSteps = 0;
+            this.setPacketCoordinates(this.getX(), this.getY(), this.getZ());
+        }
+
+        if (this.lerpSteps > 0) {
+            double d0 = this.getX() + (this.lerpX - this.getX()) / (double)this.lerpSteps;
+            double d1 = this.getY() + (this.lerpY - this.getY()) / (double)this.lerpSteps;
+            double d2 = this.getZ() + (this.lerpZ - this.getZ()) / (double)this.lerpSteps;
+            double d3 = Mth.wrapDegrees(this.lerpYRot - (double)this.yRot);
+            this.yRot = (float)((double)this.yRot + d3 / (double)this.lerpSteps);
+            this.xRot = (float)((double)this.xRot + (this.lerpXRot - (double)this.xRot) / (double)this.lerpSteps);
+            --this.lerpSteps;
+            this.setPos(d0, d1, d2);
+            this.setRot(this.yRot, this.xRot);
+        }
+    }
+
+    /**
+     * Sets a target for the client to interpolate towards over the next few ticks
+     */
+    @OnlyIn(Dist.CLIENT)
+    @Override
+    public void lerpTo(double p_180426_1_, double p_180426_3_, double p_180426_5_, float p_180426_7_, float p_180426_8_,
+        int p_180426_9_, boolean p_180426_10_) {
+        this.lerpX = p_180426_1_;
+        this.lerpY = p_180426_3_;
+        this.lerpZ = p_180426_5_;
+        this.lerpYRot = (double)p_180426_7_;
+        this.lerpXRot = (double)p_180426_8_;
+        this.lerpSteps = p_180426_9_ + 2;
+    }
+
+    /**
+     * Updates the entity motion clientside, called by packets from the server
+     */
+    @OnlyIn(Dist.CLIENT)
+    @Override
+    public void lerpMotion(double p_70016_1_, double p_70016_3_, double p_70016_5_) {
+        this.lerpXDelta = p_70016_1_;
+        this.lerpYDelta = p_70016_3_;
+        this.lerpZDelta = p_70016_5_;
+        this.setDeltaMovement(this.lerpXDelta, this.lerpYDelta, this.lerpZDelta);
+    }
+
+    private void applyNaturalSlowdown() {
+        double d0 = this.isVehicle() ? 0.95D : 0.35D;
+        this.setDeltaMovement(this.getDeltaMovement().multiply(d0, 1.0D, d0));
+    }
+
+    /**
+     * Gets the bounding box of this Entity, adjusted to take auxiliary entities into account (e.g. the tile contained
+     * by a minecart, such as a command block).
+     */
+    @OnlyIn(Dist.CLIENT)
+    @Override
+    public AABB getBoundingBoxForCulling() {
+        AABB axisalignedbb = this.getBoundingBox();
+        return this.hasCustomDisplay() ? axisalignedbb.inflate((double)Math.abs(this.getDisplayOffset()) / 16.0D)
+            : axisalignedbb;
+    }
+
+    @Override
+    public Entity getControllingPassenger() {
+        List<Entity> list = this.getPassengers();
+        return list.isEmpty() ? null : (Entity)list.get(0);
+    }
+
+    @Override
+    protected void readAdditionalSaveData(CompoundTag p_70037_1_) {
+        if (p_70037_1_.getBoolean("CustomDisplayTile")) {
+            this.setDisplayBlockState(NbtUtils.readBlockState(p_70037_1_.getCompound("DisplayState")));
+            this.setDisplayOffset(p_70037_1_.getInt("DisplayOffset"));
+        }
+
+        this.createInventory();
+        ListTag listnbt = p_70037_1_.getList("Items", 10);
+        for (int i = 0; i < listnbt.size(); ++i) {
+            CompoundTag compoundnbt = listnbt.getCompound(i);
+            int j = compoundnbt.getByte("Slot") & 255;
+            if (j < this.inventory.getContainerSize()) {
+                this.inventory.setItem(j, ItemStack.of(compoundnbt));
+            }
+        }
+    }
+
+    @Override
+    protected void addAdditionalSaveData(CompoundTag p_213281_1_) {
+        if (this.hasCustomDisplay()) {
+            p_213281_1_.putBoolean("CustomDisplayTile", true);
+            p_213281_1_.put("DisplayState", NbtUtils.writeBlockState(this.getDisplayBlockState()));
+            p_213281_1_.putInt("DisplayOffset", this.getDisplayOffset());
+        }
+
+        ListTag listnbt = new ListTag();
+        for (int i = 0; i < this.inventory.getContainerSize(); ++i) {
+            ItemStack itemstack = this.inventory.getItem(i);
+            if (!itemstack.isEmpty()) {
+                CompoundTag compoundnbt = new CompoundTag();
+                compoundnbt.putByte("Slot", (byte)i);
+                itemstack.save(compoundnbt);
+                listnbt.add(compoundnbt);
+            }
+        }
+        p_213281_1_.put("Items", listnbt);
+    }
+
+    /**
+     * Applies a velocity to the entities, to push them away from eachother.
+     */
+    @Override
+    public void push(Entity entityIn) {
+        if (!this.level.isClientSide) {
+            if (!entityIn.noPhysics && !this.noPhysics) {
+                if (!this.hasPassenger(entityIn)) {
+                    double d0 = entityIn.getX() - this.getX();
+                    double d1 = entityIn.getZ() - this.getZ();
+                    double d2 = d0 * d0 + d1 * d1;
+
+                    if (d2 >= 9.999999747378752E-5D) {
+                        d2 = (double)Mth.sqrt(d2);
+                        d0 = d0 / d2;
+                        d1 = d1 / d2;
+                        double d3 = 1.0D / d2;
+
+                        if (d3 > 1.0D) {
+                            d3 = 1.0D;
+                        }
+
+                        d0 = d0 * d3;
+                        d1 = d1 * d3;
+                        d0 = d0 * 0.10000000149011612D;
+                        d1 = d1 * 0.10000000149011612D;
+                        d0 = d0 * (double)(1.0F - this.pushthrough);
+                        d1 = d1 * (double)(1.0F - this.pushthrough);
+                        d0 = d0 * 0.5D;
+                        d1 = d1 * 0.5D;
+
+                        if (entityIn instanceof Cannon) {
+                            double d4 = entityIn.getX() - this.getX();
+                            double d5 = entityIn.getZ() - this.getZ();
+                            Vec3 vec3d = (new Vec3(d4, 0.0D, d5)).normalize();
+                            Vec3 vec3d1 = (new Vec3((double)Mth.cos(this.yRot * 0.017453292F), 0.0D,
+                                (double)Mth.sin(this.yRot * 0.017453292F))).normalize();
+                            double d6 = Math.abs(vec3d.dot(vec3d1));
+
+                            if (d6 < 0.800000011920929D) {
+                                return;
+                            }
+
+                            Vec3 vec3d2 = this.getDeltaMovement();
+                            Vec3 vec3d3 = entityIn.getDeltaMovement();
+
+                            double d7 = (vec3d3.x + vec3d2.x) / 2.0D;
+                            double d8 = (vec3d3.z + vec3d2.z) / 2.0D;
+                            this.setDeltaMovement(vec3d2.multiply(0.2D, 1.0D, 0.2D));
+                            this.push(d7 - d0, 0.0D, d8 - d1);
+                            entityIn.setDeltaMovement(vec3d3.multiply(0.2D, 1.0D, 0.2D));
+                            entityIn.push(d7 + d0, 0.0D, d8 + d1);
+                        }
+                    } else {
+                        this.push(-d0, 0.0D, -d1);
+                        entityIn.push(d0 / 4.0D, 0.0D, d1 / 4.0D);
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Sets the current amount of damage the minecart has taken. Decreases over time. The cart breaks when this is over
+     * 40.
+     */
+    public void setDamage(float p_70492_1_) {
+        this.entityData.set(DATA_ID_DAMAGE, p_70492_1_);
+    }
+
+    /**
+     * Gets the current amount of damage the minecart has taken. Decreases over time. The cart breaks when this is over
+     * 40.
+     */
+    public float getDamage() {
+        return this.entityData.get(DATA_ID_DAMAGE);
+    }
+
+    /**
+     * Sets the rolling amplitude the cart rolls while being attacked.
+     */
+    public void setHurtTime(int p_70497_1_) {
+        this.entityData.set(DATA_ID_HURT, p_70497_1_);
+    }
+
+    /**
+     * Gets the rolling amplitude the cart rolls while being attacked.
+     */
+    public int getHurtTime() {
+        return this.entityData.get(DATA_ID_HURT);
+    }
+
+    /**
+     * Sets the rolling direction the cart rolls while being attacked. Can be 1 or -1.
+     */
+    public void setHurtDir(int p_70494_1_) {
+        this.entityData.set(DATA_ID_HURTDIR, p_70494_1_);
+    }
+
+    /**
+     * Gets the rolling direction the cart rolls while being attacked. Can be 1 or -1.
+     */
+    public int getHurtDir() {
+        return this.entityData.get(DATA_ID_HURTDIR);
+    }
+
+    public BlockState getDisplayBlockState() {
+        return !this.hasCustomDisplay() ? this.getDefaultDisplayBlockState()
+            : Block.stateById(this.getEntityData().get(DATA_ID_DISPLAY_BLOCK));
+    }
+
+    public BlockState getDefaultDisplayBlockState() {
+        return Blocks.AIR.defaultBlockState();
+    }
+
+    public int getDisplayOffset() {
+        return !this.hasCustomDisplay() ? this.getDefaultDisplayOffset()
+            : this.getEntityData().get(DATA_ID_DISPLAY_OFFSET);
+    }
+
+    public int getDefaultDisplayOffset() {
+        return 6;
+    }
+
+    public void setDisplayBlockState(BlockState p_174899_1_) {
+        this.getEntityData().set(DATA_ID_DISPLAY_BLOCK, Block.getId(p_174899_1_));
+        this.setCustomDisplay(true);
+    }
+
+    public void setDisplayOffset(int p_94086_1_) {
+        this.getEntityData().set(DATA_ID_DISPLAY_OFFSET, p_94086_1_);
+        this.setCustomDisplay(true);
+    }
+
+    public boolean hasCustomDisplay() {
+        return this.getEntityData().get(DATA_ID_CUSTOM_DISPLAY);
+    }
+
+    public void setCustomDisplay(boolean p_94096_1_) {
+        this.getEntityData().set(DATA_ID_CUSTOM_DISPLAY, p_94096_1_);
+    }
+
+    @Override
+    public Packet<?> getAddEntityPacket() {
+        return new ClientboundAddEntityPacket(this);
+    }
+
+    @Override
+    public boolean interact(Player p_184230_1_, InteractionHand p_184230_2_) {
+        System.out.println("interact");
+        if (p_184230_1_.isSecondaryUseActive()) {
+            return this.openInventory(p_184230_1_);
+        } else {
+            return !this.level.isClientSide ? p_184230_1_.startRiding(this) : false;
+        }
+    }
+
+    /**
+     * Applies the given player interaction to this Entity.
+     */
+    @Override
+    public InteractionResult interactAt(Player p_184199_1_, Vec3 p_184199_2_, InteractionHand p_184199_3_) {
+        ItemStack itemstack = p_184199_1_.getItemInHand(p_184199_3_);
+        if (!itemstack.isEmpty()) {
+            if (itemstack.getItem() == Items.TORCH && this.isLookingAtTrigger(p_184199_1_)) {
+                if (p_184199_1_.isSpectator()) {
+                    return InteractionResult.SUCCESS;
+                } else if (p_184199_1_.level.isClientSide) {
+                    return InteractionResult.CONSUME;
+                } else {
+                    if (this.shoot((ServerPlayer)p_184199_1_)) {
+                        return InteractionResult.SUCCESS;
+                    }
+                }
+            } else if (this.isLookingAtBarrel(p_184199_1_)) {
+                if (p_184199_1_.isSpectator()) {
+                    return InteractionResult.SUCCESS;
+                } else if (p_184199_1_.level.isClientSide) {
+                    return InteractionResult.CONSUME;
+                } else if (itemstack.getItem() == Items.CANNONBALL && this.getBullet().isEmpty()) {
+                    this.setBullet(itemstack.split(1));
+                    this.containerChanged(this.inventory);
+
+                    // TODO: Add cannon loading sound
+                    if (this.tickCount > 20) {
+                        this.playSound(SoundEvents.ANVIL_PLACE, 0.5F, 1.0F);
+                    }
+
+                    return InteractionResult.SUCCESS;
+                } else if (itemstack.getItem() == Items.GUNPOWDER
+                    && this.getExplosive().getCount() < this.getExplosive().getMaxStackSize()) {
+                    if (this.getExplosive().sameItem(itemstack)) {
+                        this.getExplosive().grow(1);
+                        itemstack.shrink(1);
+                    } else {
+                        this.setExplosive(itemstack.split(1));
+                    }
+                    this.containerChanged(this.inventory);
+
+                    // TODO: Add cannon loading sound
+                    if (this.tickCount > 20) {
+                        this.playSound(SoundEvents.HORSE_SADDLE, 0.5F, 1.0F);
+                    }
+
+                    return InteractionResult.SUCCESS;
+                }
+            }
+            return InteractionResult.SUCCESS;
+        }
+
+        return InteractionResult.PASS;
+    }
+
+    @Override
+    public void positionRider(Entity p_184232_1_) {
+        if (this.hasPassenger(p_184232_1_)) {
+            float f = -1.0F; // rider offset
+            float f1 = (float)((this.removed ? (double)0.01F : this.getRideHeight()) + p_184232_1_.getRidingHeight());
+            if (this.getPassengers().size() > 1) {
+                int i = this.getPassengers().indexOf(p_184232_1_);
+                if (i == 0) {
+                    f = 0.2F;
+                } else {
+                    f = -0.6F;
+                }
+
+                if (p_184232_1_ instanceof Animal) {
+                    f = (float)((double)f + 0.2D);
+                }
+            }
+
+            Vec3 vec3d = (new Vec3((double)f, 0.0D, 0.0D))
+                .yRot(-this.yRot * ((float)Math.PI / 180F) - ((float)Math.PI / 2F));
+            p_184232_1_.setPos(this.getX() + vec3d.x, this.getY() + (double)f1, this.getZ() + vec3d.z);
+            p_184232_1_.yRot += this.deltaYRotation;
+            p_184232_1_.setYHeadRot(p_184232_1_.getYHeadRot() + this.deltaYRotation);
+            this.clampRotation(p_184232_1_);
+            if (p_184232_1_ instanceof Animal && this.getPassengers().size() > 1) {
+                int j = p_184232_1_.getId() % 2 == 0 ? 90 : 270;
+                p_184232_1_.setYBodyRot(((Animal)p_184232_1_).yBodyRot + (float)j);
+                p_184232_1_.setYHeadRot(p_184232_1_.getYHeadRot() + (float)j);
+            }
+
+            Vec3 cannonViewVector = this.getViewVector(1.0F).multiply(1.0D, 0.0D, 1.0D);
+            Vec3 riderPos = new Vec3(this.getX(), this.getY() - 0.25F, this.getZ()).subtract(cannonViewVector);
+
+            //Eject operator if not on solid block
+            if (!p_184232_1_.level.getBlockState(new BlockPos(riderPos)).getMaterial().isSolid()) {
+                p_184232_1_.stopRiding();
+            }
+        }
+    }
+
+    /**
+     * Gets the barrel angle of the cannon.
+     */
+    public float getBarrelAngle() {
+        return this.xRot;
+    }
+
+    /**
+     * Gets the cannon status if is ready to shoot.
+     */
+    public boolean isReady() {
+        return this.getEntityData().get(DATA_ISREADY);
+    }
+
+    public void setReady(boolean ready) {
+        this.getEntityData().set(DATA_ISREADY, ready);
+    }
+
+    public ItemStack getExplosive() {
+        return this.inventory.getItem(0);
+    }
+
+    public void setExplosive(ItemStack explosive) {
+        this.inventory.setItem(0, explosive);
+    }
+
+    public ItemStack getBullet() {
+        return this.inventory.getItem(1);
+    }
+
+    public void setBullet(ItemStack bullet) {
+        this.inventory.setItem(1, bullet);
+    }
+
+    /**
+     * Return shoot power of cannon, which is used to set start velocity of bullet. Calculated power is based on
+     * function {@code ln(x+1)} where x are quantity of explosives.
+     * 
+     * @return shot power based on quantity of explosives loaded
+     */
+    public float getShootPower() {
+        ItemStack explosive = getExplosive();
+        if (!explosive.isEmpty()) {
+            float power = (float)Math.log1p(explosive.getCount());
+            return power;
+        } else
+            return 0.0F;
+    }
+
+    /**
+     * Update the cannon's speed, based on momentum.
+     */
+    private void moveCannon() {
+        double d0 = this.isNoGravity() ? 0.0D : (double)-0.09F;
+        float landFriction = this.getControllingPassenger() instanceof Player ? 0.9F : 0.5F;
+
+        Vec3 vec3d = this.getDeltaMovement();
+        this.setDeltaMovement(vec3d.x * (double)landFriction, vec3d.y + d0, vec3d.z * (double)landFriction);
+        this.deltaYRotation *= landFriction / 2.0F;
+        this.deltaXRotation *= 0.4F;
+    }
+
+    /**
+     * Used to control cannon.
+     */
+    private void controlCannon() {
+        if (this.isVehicle()) {
+            float f = 0.0F;
+
+            if (this.inputSkewBarrel) {
+                if (this.inputForward) {
+                    this.deltaXRotation -= this.barrelSpeed;
+                }
+
+                if (this.inputBackward) {
+                    this.deltaXRotation += this.barrelSpeed;
+                }
+
+                this.xRot += this.deltaXRotation;
+                this.xRot = Mth.clamp(this.xRot, minAngle, maxAngle);
+            } else {
+                if (this.inputLeft) {
+                    this.deltaYRotation -= this.rotationSpeed;
+                }
+
+                if (this.inputRight) {
+                    this.deltaYRotation += this.rotationSpeed;
+                }
+
+                if (this.inputRight != this.inputLeft && !this.inputForward && !this.inputBackward) {
+                    f += 0.001F;
+                }
+
+                this.yRot += this.deltaYRotation;
+                if (this.inputForward) {
+                    f += getMaxSpeed();
+                }
+
+                if (this.inputBackward) {
+                    f -= getMaxSpeed() / 2.0F;
+                }
+            }
+
+            // Add cannon movement
+            this.setDeltaMovement(
+                this.getDeltaMovement().add((double)(Mth.sin(-this.yRot * ((float)Math.PI / 180F)) * f), 0.0D,
+                    (double)(Mth.cos(this.yRot * ((float)Math.PI / 180F)) * f)));
+        }
+    }
+
+    @OnlyIn(Dist.CLIENT)
+    public void setInput(boolean left, boolean right, boolean forward, boolean backward, boolean shoot) {
+        this.inputLeft = left;
+        this.inputRight = right;
+        this.inputForward = forward;
+        this.inputBackward = backward;
+        this.inputSkewBarrel = shoot;
+    }
+
+    /**
+     * Applies this cannon's yaw to the given entity. Used to update the orientation of its passenger.
+     */
+    protected void clampRotation(Entity p_184454_1_) {
+        p_184454_1_.setYBodyRot(this.yRot);
+        float f = Mth.wrapDegrees(p_184454_1_.yRot - this.yRot);
+        float f1 = Mth.clamp(f, -85.0F, 85.0F);
+        p_184454_1_.yRotO += f1 - f;
+        p_184454_1_.yRot += f1 - f;
+        p_184454_1_.setYHeadRot(p_184454_1_.yRot);
+    }
+
+    /**
+     * Handles cannon shot
+     * 
+     * @param gunner player which fires cannon with torch
+     * 
+     * @return true if shoot succeed
+     */
+    public boolean shoot(ServerPlayer gunner) {
+        if (!this.isReady()) {
+            return false;
+        }
+
+        Vec3 vec3d = this.getViewVector(1.0F);
+        Vec3 vec3dcannonball = new Vec3(this.getX() + vec3d.x, this.getEyePosition(1.0F).y + vec3d.y,
+            this.getZ() + vec3d.z);
+        float shootPower = this.getShootPower();
+
+        if (!this.level.isClientSide) {
+            if (!this.getBullet().isEmpty()) { // Release bullet if loaded
+                Cannonball entitycannonball = new Cannonball(this.level, this, gunner);
+                vec3dcannonball = new Vec3(vec3dcannonball.x, vec3dcannonball.y - entitycannonball.getBbHeight() / 2.0F,
+                    vec3dcannonball.z);
+                entitycannonball.setPos(vec3dcannonball.x, vec3dcannonball.y, vec3dcannonball.z);
+                entitycannonball.shootFromRotation(this, this.getBarrelAngle(), this.yRot, 0.0F, shootPower, 2.75F);
+
+                this.level.addFreshEntity(entitycannonball);
+            }
+
+            this.getBullet().setCount(0);
+            this.getExplosive().setCount(0);
+            this.containerChanged(this.inventory);
+        }
+
+        // Add shoot knockback
+        this.setDeltaMovement(this.getDeltaMovement().add(vec3d.scale(-Math.log(shootPower + 1.0F))));
+
+        // Play cannon shoot sound @LevelRenderer#levelEvent
+        this.level.levelEvent((Player)null, 4000, new BlockPos(this), 0);
+
+        // Do smoke
+        this.level.levelEvent((Player)null, 2008, new BlockPos(vec3dcannonball), 3);
+//        TODO try to do better smoke positioning
+//        this.level.addParticle(ParticleTypes.EXPLOSION, entitycannonball.getX(), entitycannonball.getY(),
+//            entitycannonball.getZ(), 1.0D, 0.0D, 0.0D);
+
+        return true;
+    }
+
+    /**
+     * Checks to see if interacting player is looking on trrigger.
+     */
+    private boolean isLookingAtTrigger(Player p_70821_1_) {
+        Vec3 vec3dplayer = p_70821_1_.getViewVector(1.0F);
+        Vec3 vec3dtrigger = this.getEyePosition(1.0F).subtract(this.getViewVector(1.0F));
+        Vec3 vec3dbetween = vec3dtrigger.subtract(p_70821_1_.getEyePosition(1.0F)).normalize();
+
+        boolean lookingOnTrigger = vec3dbetween.dot(vec3dplayer) > 0.985D;
+        boolean behind = this.getViewVector(1.0F).dot(vec3dplayer) > 0.5D;
+
+        return lookingOnTrigger && behind;
+    }
+
+    /**
+     * Checks to see if interacting player is looking on barrel top.
+     */
+    private boolean isLookingAtBarrel(Player p_70821_1_) {
+        Vec3 vec3dplayer = p_70821_1_.getViewVector(1.0F);
+        Vec3 vec3dbarrel = this.getEyePosition(1.0F).add(this.getViewVector(1.0F));
+        Vec3 vec3dbetween = vec3dbarrel.subtract(p_70821_1_.getEyePosition(1.0F)).normalize();
+
+        boolean lookingOnBarrel = vec3dbetween.dot(vec3dplayer) > 0.985D;
+        boolean inFront = this.getViewVector(1.0F).dot(vec3dplayer) < -0.55D;
+
+        return lookingOnBarrel && inFront;
+    }
+
+    protected int getInventorySize() {
+        return 2;
+    }
+
+    @Override
+    public AbstractContainerMenu createMenu(int containerId, Inventory inventory, Player player) {
+        return new CannonMenu(MenuType.CANNON, containerId, inventory, this.inventory, this);
+    }
+
+    public boolean openInventory(Player p_110199_1_) {
+        if (!this.level.isClientSide && (!this.isVehicle() || !this.hasPassenger(p_110199_1_))) {
+            p_110199_1_.openMenu(this);
+            return true;
+        }
+        return false;
+    }
+
+    protected void createInventory() {
+        SimpleContainer inventory = this.inventory;
+        this.inventory = new SimpleContainer(this.getInventorySize());
+        if (inventory != null) {
+            inventory.removeListener(this);
+            int i = Math.min(inventory.getContainerSize(), this.inventory.getContainerSize());
+
+            for (int j = 0; j < i; ++j) {
+                ItemStack itemstack = inventory.getItem(j);
+                if (!itemstack.isEmpty()) {
+                    this.inventory.setItem(j, itemstack.copy());
+                }
+            }
+        }
+
+        this.inventory.addListener(this);
+        this.containerChanged(this.inventory);
+    }
+
+    @Override
+    public void containerChanged(Container p_76316_1_) {
+        ItemStack explosive = getExplosive();
+        ItemStack bullet = getBullet();
+
+        boolean hasExplosive = !explosive.isEmpty() && explosive.getItem() == Items.GUNPOWDER;
+        boolean hasBullet = !bullet.isEmpty() && bullet.getItem() == Items.CANNONBALL;
+
+        this.setReady(hasExplosive);
+    }
+}
\ No newline at end of file
